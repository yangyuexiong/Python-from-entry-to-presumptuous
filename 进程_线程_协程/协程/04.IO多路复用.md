### IO 多路复用
```text
IO模型:
    阻塞IO(BIO)
    非阻塞IO(NIO)
    IO复用
    信号驱动式IO
    异步IO(AIO)

非阻塞IO(NIO):

    不停检查状态,检查链接是否建立完成,耗费CPU,将数据从内核复制到用户空间,再将数据从操作系统地址复制到应用的缓存中

    应用场景:
        不依赖前面链接是否建立完成,就再次发起其他链接或者计算等操作

IO复用:
    *数据从内核复制到用户空间,依旧没有被节省
    *一个进程监听多个描述符(文件句柄或socket),一旦某个描述符准备就绪(可读写)就通知程序操作处理
    *本质上(select,poll,epoll)都属于同步IO,因为都需要在描述符准备就绪后,自己负责读写操作,这个读写操作的过程是阻塞的,而异步IO不需要自行读写操作

    select:
        1.监听3类描述符 writerfds,readfds,exceptfds
        2.调用后select函数阻塞,直到描述符就绪或者超时,函数返回,返回后通过遍历fdset找到就绪的描述符
        优点:
            1.支持所有平台(win,mac,linux)
        缺点:
            1.监听的描述符数量最大限制一般是1024,如果通过宏定义或者重新编译内核的方式去提升也会造成效率的降低

    poll:
        1.使用pollfd监听描述符
        2.需要轮询pollfd来获取就绪的描述符(与select相同)
        优点:
            1.监听的描述符数量没有最大限制
            2.查询效率高

    epoll:
        1.是select和poll的增强版,没有描述符限制,使用一个文件描述符管理多个描述符,将用户关系的文件描述符的事件存放到内核的一个事件表中,因此在内核空间到用户空间的复制只需要一次
        2.查询使用了红黑树数据结构
    
    使用场景:
        1.高并发,连接活跃度不高的情况下 epoll 比 select 优
        2.并发不高,连接活跃度高的情况下 select 比 epoll 优

  
异步IO(AIO):
    *操作系统会将数据从内核复制到用户空间,再给到信号处理程序发起一个数据,节省了中间每次将内核复制数据到用户空间的过程
    

```